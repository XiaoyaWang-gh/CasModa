public static List<Message> toOpenAiMessages(List<ChatMessage> messages) {        return messages.stream()                .map(InternalOpenAiHelper::toOpenAiMessage)                .collect(toList());    }
public static Message toOpenAiMessage(ChatMessage message) {        if (message instanceof SystemMessage) {            return dev.ai4j.openai4j.chat.SystemMessage.from(((SystemMessage) message).text());        }        if (message instanceof UserMessage) {            UserMessage userMessage = (UserMessage) message;            if (userMessage.hasSingleText()) {                return dev.ai4j.openai4j.chat.UserMessage.builder()                        .content(userMessage.text())                        .name(userMessage.name())                        .build();            } else {                return dev.ai4j.openai4j.chat.UserMessage.builder()                        .content(userMessage.contents().stream()                                .map(InternalOpenAiHelper::toOpenAiContent)                                .collect(toList()))                        .name(userMessage.name())                        .build();            }        }        if (message instanceof AiMessage) {            AiMessage aiMessage = (AiMessage) message;            if (!aiMessage.hasToolExecutionRequests()) {                return AssistantMessage.from(aiMessage.text());            }            ToolExecutionRequest toolExecutionRequest = aiMessage.toolExecutionRequests().get(0);            if (toolExecutionRequest.id() == null) {                FunctionCall functionCall = FunctionCall.builder()                        .name(toolExecutionRequest.name())                        .arguments(toolExecutionRequest.arguments())                        .build();                return AssistantMessage.builder()                        .functionCall(functionCall)                        .build();            }            List<ToolCall> toolCalls = aiMessage.toolExecutionRequests().stream()                    .map(it -> ToolCall.builder()                            .id(it.id())                            .type(FUNCTION)                            .function(FunctionCall.builder()                                    .name(it.name())                                    .arguments(it.arguments())                                    .build())                            .build())                    .collect(toList());            return AssistantMessage.builder()                    .toolCalls(toolCalls)                    .build();        }        if (message instanceof ToolExecutionResultMessage) {            ToolExecutionResultMessage toolExecutionResultMessage = (ToolExecutionResultMessage) message;            if (toolExecutionResultMessage.id() == null) {                return FunctionMessage.from(toolExecutionResultMessage.toolName(), toolExecutionResultMessage.text());            }            return ToolMessage.from(toolExecutionResultMessage.id(), toolExecutionResultMessage.text());        }        throw illegalArgument("Unknown message type: " + message.type());    }
public static List<Tool> toTools(Collection<ToolSpecification> toolSpecifications) {        return toolSpecifications.stream()                .map(InternalOpenAiHelper::toTool)                .collect(toList());    }
public static AiMessage aiMessageFrom(ChatCompletionResponse response) {        AssistantMessage assistantMessage = response.choices().get(0).message();        List<ToolCall> toolCalls = assistantMessage.toolCalls();        if (!isNullOrEmpty(toolCalls)) {            List<ToolExecutionRequest> toolExecutionRequests = toolCalls.stream()                    .filter(toolCall -> toolCall.type() == FUNCTION)                    .map(InternalOpenAiHelper::toToolExecutionRequest)                    .collect(toList());            return aiMessage(toolExecutionRequests);        }        FunctionCall functionCall = assistantMessage.functionCall();        if (functionCall != null) {            ToolExecutionRequest toolExecutionRequest = ToolExecutionRequest.builder()                    .name(functionCall.name())                    .arguments(functionCall.arguments())                    .build();            return aiMessage(toolExecutionRequest);        }        return aiMessage(assistantMessage.content());    }
public static TokenUsage tokenUsageFrom(Usage openAiUsage) {        if (openAiUsage == null) {            return null;        }        return new TokenUsage(                openAiUsage.promptTokens(),                openAiUsage.completionTokens(),                openAiUsage.totalTokens()        );    }
public static FinishReason finishReasonFrom(String openAiFinishReason) {        if (openAiFinishReason == null) {            return null;        }        switch (openAiFinishReason) {            case "stop":                return STOP;            case "length":                return LENGTH;            case "tool_calls":            case "function_call":                return TOOL_EXECUTION;            case "content_filter":                return CONTENT_FILTER;            default:                return null;        }    }
----------------------------------------------------------------------------------------------------
public Response<AiMessage> generate(List<ChatMessage> messages) {        return generate(messages, null, null);    }
public Response<AiMessage> generate(List<ChatMessage> messages, List<ToolSpecification> toolSpecifications) {        return generate(messages, toolSpecifications, null);    }
public Response<AiMessage> generate(List<ChatMessage> messages, ToolSpecification toolSpecification) {        return generate(messages, singletonList(toolSpecification), toolSpecification);    }
public int estimateTokenCount(List<ChatMessage> messages) {        return tokenizer.estimateTokenCountInMessages(messages);    }
public static OpenAiChatModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiChatModelBuilder builder() {        for (OpenAiChatModelBuilderFactory factory : loadFactories(OpenAiChatModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiChatModelBuilder();    }
public OpenAiChatModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiChatModelBuilder modelName(OpenAiChatModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public Response<List<Embedding>> embedAll(List<TextSegment> textSegments) {        List<String> texts = textSegments.stream()                .map(TextSegment::text)                .collect(toList());        return embedTexts(texts);    }
public int estimateTokenCount(String text) {        return tokenizer.estimateTokenCountInText(text);    }
public static OpenAiEmbeddingModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiEmbeddingModelBuilder builder() {        for (OpenAiEmbeddingModelBuilderFactory factory : loadFactories(OpenAiEmbeddingModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiEmbeddingModelBuilder();    }
public OpenAiEmbeddingModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiEmbeddingModelBuilder modelName(OpenAiEmbeddingModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public Response<Image> generate(String prompt) {        GenerateImagesRequest request = requestBuilder(prompt).build();        GenerateImagesResponse response = withRetry(() -> client.imagesGeneration(request), maxRetries).execute();        return Response.from(fromImageData(response.data().get(0)));    }
public Response<List<Image>> generate(String prompt, int n) {        GenerateImagesRequest request = requestBuilder(prompt).n(n).build();        GenerateImagesResponse response = withRetry(() -> client.imagesGeneration(request), maxRetries).execute();        return Response.from(                response.data().stream().map(OpenAiImageModel::fromImageData).collect(Collectors.toList())        );    }
public static OpenAiImageModelBuilder builder() {        for (OpenAiImageModelBuilderFactory factory : loadFactories(OpenAiImageModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiImageModelBuilder();    }
public static OpenAiImageModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public OpenAiImageModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiImageModelBuilder modelName(OpenAiImageModelName modelName) {            this.modelName = modelName.toString();            return this;        }
public OpenAiImageModelBuilder withPersisting() {            return withPersisting(true);        }
public OpenAiImageModelBuilder withPersisting(Boolean withPersisting) {            this.withPersisting = withPersisting;            return this;        }
----------------------------------------------------------------------------------------------------
public Response<String> generate(String prompt) {        CompletionRequest request = CompletionRequest.builder()                .model(modelName)                .prompt(prompt)                .temperature(temperature)                .build();        CompletionResponse response = withRetry(() -> client.completion(request).execute(), maxRetries);        CompletionChoice completionChoice = response.choices().get(0);        return Response.from(                completionChoice.text(),                tokenUsageFrom(response.usage()),                finishReasonFrom(completionChoice.finishReason())        );    }
public int estimateTokenCount(String prompt) {        return tokenizer.estimateTokenCountInText(prompt);    }
public static OpenAiLanguageModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiLanguageModelBuilder builder() {        for (OpenAiLanguageModelBuilderFactory factory : loadFactories(OpenAiLanguageModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiLanguageModelBuilder();    }
public OpenAiLanguageModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiLanguageModelBuilder modelName(OpenAiLanguageModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public Response<Moderation> moderate(String text) {        return moderateInternal(singletonList(text));    }
public Response<Moderation> moderate(List<ChatMessage> messages) {        List<String> inputs = messages.stream()                .map(ChatMessage::text)                .collect(toList());        return moderateInternal(inputs);    }
public static OpenAiModerationModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiModerationModelBuilder builder() {        for (OpenAiModerationModelBuilderFactory factory : loadFactories(OpenAiModerationModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiModerationModelBuilder();    }
public OpenAiModerationModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiModerationModelBuilder modelName(OpenAiModerationModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public void generate(List<ChatMessage> messages, StreamingResponseHandler<AiMessage> handler) {        generate(messages, null, null, handler);    }
public void generate(List<ChatMessage> messages, List<ToolSpecification> toolSpecifications, StreamingResponseHandler<AiMessage> handler) {        generate(messages, toolSpecifications, null, handler);    }
public void generate(List<ChatMessage> messages, ToolSpecification toolSpecification, StreamingResponseHandler<AiMessage> handler) {        generate(messages, null, toolSpecification, handler);    }
public int estimateTokenCount(List<ChatMessage> messages) {        return tokenizer.estimateTokenCountInMessages(messages);    }
public static OpenAiStreamingChatModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiStreamingChatModelBuilder builder() {        for (OpenAiStreamingChatModelBuilderFactory factory : loadFactories(OpenAiStreamingChatModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiStreamingChatModelBuilder();    }
public OpenAiStreamingChatModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiStreamingChatModelBuilder modelName(OpenAiChatModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public void generate(String prompt, StreamingResponseHandler<String> handler) {        CompletionRequest request = CompletionRequest.builder()                .model(modelName)                .prompt(prompt)                .temperature(temperature)                .build();        int inputTokenCount = tokenizer.estimateTokenCountInText(prompt);        OpenAiStreamingResponseBuilder responseBuilder = new OpenAiStreamingResponseBuilder(inputTokenCount);        client.completion(request)                .onPartialResponse(partialResponse -> {                    responseBuilder.append(partialResponse);                    String token = partialResponse.text();                    if (token != null) {                        handler.onNext(token);                    }                })                .onComplete(() -> {                    Response<AiMessage> response = responseBuilder.build(tokenizer, false);                    handler.onComplete(Response.from(                            response.content().text(),                            response.tokenUsage(),                            response.finishReason()                    ));                })                .onError(handler::onError)                .execute();    }
public int estimateTokenCount(String prompt) {        return tokenizer.estimateTokenCountInText(prompt);    }
public static OpenAiStreamingLanguageModel withApiKey(String apiKey) {        return builder().apiKey(apiKey).build();    }
public static OpenAiStreamingLanguageModelBuilder builder() {        for (OpenAiStreamingLanguageModelBuilderFactory factory : loadFactories(OpenAiStreamingLanguageModelBuilderFactory.class)) {            return factory.get();        }        return new OpenAiStreamingLanguageModelBuilder();    }
public OpenAiStreamingLanguageModelBuilder modelName(String modelName) {            this.modelName = modelName;            return this;        }
public OpenAiStreamingLanguageModelBuilder modelName(OpenAiLanguageModelName modelName) {            this.modelName = modelName.toString();            return this;        }
----------------------------------------------------------------------------------------------------
public void append(ChatCompletionResponse partialResponse) {        if (partialResponse == null) {            return;        }        List<ChatCompletionChoice> choices = partialResponse.choices();        if (choices == null || choices.isEmpty()) {            return;        }        ChatCompletionChoice chatCompletionChoice = choices.get(0);        if (chatCompletionChoice == null) {            return;        }        String finishReason = chatCompletionChoice.finishReason();        if (finishReason != null) {            this.finishReason = finishReason;        }        Delta delta = chatCompletionChoice.delta();        if (delta == null) {            return;        }        String content = delta.content();        if (content != null) {            contentBuilder.append(content);            return;        }        if (delta.functionCall() != null) {            FunctionCall functionCall = delta.functionCall();            if (functionCall.name() != null) {                toolNameBuilder.append(functionCall.name());            }            if (functionCall.arguments() != null) {                toolArgumentsBuilder.append(functionCall.arguments());            }        }        if (delta.toolCalls() != null && !delta.toolCalls().isEmpty()) {            ToolCall toolCall = delta.toolCalls().get(0);            ToolExecutionRequestBuilder toolExecutionRequestBuilder                    = indexToToolExecutionRequestBuilder.computeIfAbsent(toolCall.index(), idx -> new ToolExecutionRequestBuilder());            if (toolCall.id() != null) {                toolExecutionRequestBuilder.idBuilder.append(toolCall.id());            }            FunctionCall functionCall = toolCall.function();            if (functionCall.name() != null) {                toolExecutionRequestBuilder.nameBuilder.append(functionCall.name());            }            if (functionCall.arguments() != null) {                toolExecutionRequestBuilder.argumentsBuilder.append(functionCall.arguments());            }        }    }
public void append(CompletionResponse partialResponse) {        if (partialResponse == null) {            return;        }        List<CompletionChoice> choices = partialResponse.choices();        if (choices == null || choices.isEmpty()) {            return;        }        CompletionChoice completionChoice = choices.get(0);        if (completionChoice == null) {            return;        }        String finishReason = completionChoice.finishReason();        if (finishReason != null) {            this.finishReason = finishReason;        }        String token = completionChoice.text();        if (token != null) {            contentBuilder.append(token);        }    }
public Response<AiMessage> build(Tokenizer tokenizer, boolean forcefulToolExecution) {        String content = contentBuilder.toString();        if (!content.isEmpty()) {            return Response.from(                    AiMessage.from(content),                    tokenUsage(content, tokenizer),                    finishReasonFrom(finishReason)            );        }        String toolName = toolNameBuilder.toString();        if (!toolName.isEmpty()) {            ToolExecutionRequest toolExecutionRequest = ToolExecutionRequest.builder()                    .name(toolName)                    .arguments(toolArgumentsBuilder.toString())                    .build();            return Response.from(                    AiMessage.from(toolExecutionRequest),                    tokenUsage(singletonList(toolExecutionRequest), tokenizer, forcefulToolExecution),                    finishReasonFrom(finishReason)            );        }        if (!indexToToolExecutionRequestBuilder.isEmpty()) {            List<ToolExecutionRequest> toolExecutionRequests = indexToToolExecutionRequestBuilder.values().stream()                    .map(it -> ToolExecutionRequest.builder()                            .id(it.idBuilder.toString())                            .name(it.nameBuilder.toString())                            .arguments(it.argumentsBuilder.toString())                            .build())                    .collect(toList());            return Response.from(                    AiMessage.from(toolExecutionRequests),                    tokenUsage(toolExecutionRequests, tokenizer, forcefulToolExecution),                    finishReasonFrom(finishReason)            );        }        return null;    }
----------------------------------------------------------------------------------------------------
public int estimateTokenCountInText(String text) {        return encoding.orElseThrow(unknownModelException())                .countTokensOrdinary(text);    }
public int estimateTokenCountInMessage(ChatMessage message) {        int tokenCount = 1;         tokenCount += extraTokensPerMessage();        if (message instanceof SystemMessage) {            tokenCount += estimateTokenCountIn((SystemMessage) message);        } else if (message instanceof UserMessage) {            tokenCount += estimateTokenCountIn((UserMessage) message);        } else if (message instanceof AiMessage) {            tokenCount += estimateTokenCountIn((AiMessage) message);        } else if (message instanceof ToolExecutionResultMessage) {            tokenCount += estimateTokenCountIn((ToolExecutionResultMessage) message);        } else {            throw new IllegalArgumentException("Unknown message type: " + message);        }        return tokenCount;    }
public int estimateTokenCountInMessages(Iterable<ChatMessage> messages) {                int tokenCount = 3;         for (ChatMessage message : messages) {            tokenCount += estimateTokenCountInMessage(message);        }        return tokenCount;    }
public int estimateTokenCountInToolSpecifications(Iterable<ToolSpecification> toolSpecifications) {        int tokenCount = 16;        for (ToolSpecification toolSpecification : toolSpecifications) {            tokenCount += 6;            tokenCount += estimateTokenCountInText(toolSpecification.name());            if (toolSpecification.description() != null) {                tokenCount += 2;                tokenCount += estimateTokenCountInText(toolSpecification.description());            }            tokenCount += estimateTokenCountInToolParameters(toolSpecification.parameters());        }        return tokenCount;    }
public int estimateTokenCountInForcefulToolSpecification(ToolSpecification toolSpecification) {        int tokenCount = estimateTokenCountInToolSpecifications(singletonList(toolSpecification));        tokenCount += 4;        tokenCount += estimateTokenCountInText(toolSpecification.name());        if (isOneOfLatestModels()) {            tokenCount += 3;        }        return tokenCount;    }
public List<Integer> encode(String text) {        return encoding.orElseThrow(unknownModelException())                .encodeOrdinary(text).boxed();    }
public List<Integer> encode(String text, int maxTokensToEncode) {        return encoding.orElseThrow(unknownModelException())                .encodeOrdinary(text, maxTokensToEncode).getTokens().boxed();    }
public String decode(List<Integer> tokens) {        IntArrayList intArrayList = new IntArrayList();        for (Integer token : tokens) {            intArrayList.add(token);        }        return encoding.orElseThrow(unknownModelException())                .decode(intArrayList);    }
public int estimateTokenCountInToolExecutionRequests(Iterable<ToolExecutionRequest> toolExecutionRequests) {        int tokenCount = 0;        int toolsCount = 0;        int toolsWithArgumentsCount = 0;        int toolsWithoutArgumentsCount = 0;        int totalArgumentsCount = 0;        for (ToolExecutionRequest toolExecutionRequest : toolExecutionRequests) {            tokenCount += 4;            tokenCount += estimateTokenCountInText(toolExecutionRequest.name());            tokenCount += estimateTokenCountInText(toolExecutionRequest.arguments());            int argumentCount = countArguments(toolExecutionRequest.arguments());            if (argumentCount == 0) {                toolsWithoutArgumentsCount++;            } else {                toolsWithArgumentsCount++;            }            totalArgumentsCount += argumentCount;            toolsCount++;        }        if (modelName.equals(GPT_3_5_TURBO_1106.toString()) || isOneOfLatestGpt4Models()) {            tokenCount += 16;            tokenCount += 3 * toolsWithoutArgumentsCount;            tokenCount += toolsCount;            if (totalArgumentsCount > 0) {                tokenCount -= 1;                tokenCount -= 2 * totalArgumentsCount;                tokenCount += 2 * toolsWithArgumentsCount;                tokenCount += toolsCount;            }        }        if (modelName.equals(GPT_4_1106_PREVIEW.toString())) {            tokenCount += 3;            if (toolsCount > 1) {                tokenCount += 18;                tokenCount += 15 * toolsCount;                tokenCount += totalArgumentsCount;                tokenCount -= 3 * toolsWithoutArgumentsCount;            }        }        return tokenCount;    }
public int estimateTokenCountInForcefulToolExecutionRequest(ToolExecutionRequest toolExecutionRequest) {        if (isOneOfLatestGpt4Models()) {            int argumentsCount = countArguments(toolExecutionRequest.arguments());            if (argumentsCount == 0) {                return 1;            } else {                return estimateTokenCountInText(toolExecutionRequest.arguments());            }        }        int tokenCount = estimateTokenCountInToolExecutionRequests(singletonList(toolExecutionRequest));        tokenCount -= 4;        tokenCount -= estimateTokenCountInText(toolExecutionRequest.name());        if (modelName.equals(GPT_3_5_TURBO_1106.toString())) {            int argumentsCount = countArguments(toolExecutionRequest.arguments());            if (argumentsCount == 0) {                return 1;            }            tokenCount -= 19;            tokenCount += 2 * argumentsCount;        }        return tokenCount;    }
----------------------------------------------------------------------------------------------------
