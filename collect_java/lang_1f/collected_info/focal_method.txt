public static int toInt(final String str) {        return toInt(str, 0);    }
public static int toInt(final String str, final int defaultValue) {        if(str == null) {            return defaultValue;        }        try {            return Integer.parseInt(str);        } catch (final NumberFormatException nfe) {            return defaultValue;        }    }
public static long toLong(final String str) {        return toLong(str, 0L);    }
public static long toLong(final String str, final long defaultValue) {        if (str == null) {            return defaultValue;        }        try {            return Long.parseLong(str);        } catch (final NumberFormatException nfe) {            return defaultValue;        }    }
public static float toFloat(final String str) {        return toFloat(str, 0.0f);    }
public static float toFloat(final String str, final float defaultValue) {      if (str == null) {          return defaultValue;      }           try {          return Float.parseFloat(str);      } catch (final NumberFormatException nfe) {          return defaultValue;      }    }
public static double toDouble(final String str) {        return toDouble(str, 0.0d);    }
public static double toDouble(final String str, final double defaultValue) {      if (str == null) {          return defaultValue;      }      try {          return Double.parseDouble(str);      } catch (final NumberFormatException nfe) {          return defaultValue;      }    }
public static byte toByte(final String str) {        return toByte(str, (byte) 0);    }
public static byte toByte(final String str, final byte defaultValue) {        if(str == null) {            return defaultValue;        }        try {            return Byte.parseByte(str);        } catch (final NumberFormatException nfe) {            return defaultValue;        }    }
public static short toShort(final String str) {        return toShort(str, (short) 0);    }
public static short toShort(final String str, final short defaultValue) {        if(str == null) {            return defaultValue;        }        try {            return Short.parseShort(str);        } catch (final NumberFormatException nfe) {            return defaultValue;        }    }
public static Number createNumber(final String str) throws NumberFormatException {        if (str == null) {            return null;        }        if (StringUtils.isBlank(str)) {            throw new NumberFormatException("A blank string is not a valid number");        }                final String[] hex_prefixes = {"0x", "0X", "-0x", "-0X", "#", "-#"};        int pfxLen = 0;        for(final String pfx : hex_prefixes) {            if (str.startsWith(pfx)) {                pfxLen += pfx.length();                break;            }        }        if (pfxLen > 0) {             char firstSigDigit = 0;             for(int i = pfxLen; i < str.length(); i++) {                firstSigDigit = str.charAt(i);                if (firstSigDigit == '0') {                     pfxLen++;                } else {                    break;                }            }            final int hexDigits = str.length() - pfxLen;            if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) {                 return createBigInteger(str);            }            if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) {                 return createLong(str);            }            return createInteger(str);        }        final char lastChar = str.charAt(str.length() - 1);        String mant;        String dec;        String exp;        final int decPos = str.indexOf('.');        final int expPos = str.indexOf('e') + str.indexOf('E') + 1;                         int numDecimals = 0;         if (decPos > -1) {             if (expPos > -1) {                 if (expPos < decPos || expPos > str.length()) {                     throw new NumberFormatException(str + " is not a valid number.");                }                dec = str.substring(decPos + 1, expPos);            } else {                dec = str.substring(decPos + 1);            }            mant = str.substring(0, decPos);            numDecimals = dec.length();         } else {            if (expPos > -1) {                if (expPos > str.length()) {                     throw new NumberFormatException(str + " is not a valid number.");                }                mant = str.substring(0, expPos);            } else {                mant = str;            }            dec = null;        }        if (!Character.isDigit(lastChar) && lastChar != '.') {            if (expPos > -1 && expPos < str.length() - 1) {                exp = str.substring(expPos + 1, str.length() - 1);            } else {                exp = null;            }                        final String numeric = str.substring(0, str.length() - 1);            final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);            switch (lastChar) {                case 'l' :                case 'L' :                    if (dec == null                        && exp == null                        && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {                        try {                            return createLong(numeric);                        } catch (final NumberFormatException nfe) {                                                     }                        return createBigInteger(numeric);                    }                    throw new NumberFormatException(str + " is not a valid number.");                case 'f' :                case 'F' :                    try {                        final Float f = NumberUtils.createFloat(numeric);                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {                                                                                    return f;                        }                    } catch (final NumberFormatException nfe) {                                             }                                    case 'd' :                case 'D' :                    try {                        final Double d = NumberUtils.createDouble(numeric);                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {                            return d;                        }                    } catch (final NumberFormatException nfe) {                                             }                    try {                        return createBigDecimal(numeric);                    } catch (final NumberFormatException e) {                                             }                                    default :                    throw new NumberFormatException(str + " is not a valid number.");            }        }                        if (expPos > -1 && expPos < str.length() - 1) {            exp = str.substring(expPos + 1, str.length());        } else {            exp = null;        }        if (dec == null && exp == null) {                         try {                return createInteger(str);            } catch (final NumberFormatException nfe) {                             }            try {                return createLong(str);            } catch (final NumberFormatException nfe) {                             }            return createBigInteger(str);        }                final boolean allZeros = isAllZeros(mant) && isAllZeros(exp);        try {            if(numDecimals <= 7){                final Float f = createFloat(str);                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {                    return f;                }            }        } catch (final NumberFormatException nfe) {                     }        try {            if(numDecimals <= 16){                final Double d = createDouble(str);                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {                    return d;                }            }        } catch (final NumberFormatException nfe) {                     }        return createBigDecimal(str);    }
public static Float createFloat(final String str) {        if (str == null) {            return null;        }        return Float.valueOf(str);    }
public static Double createDouble(final String str) {        if (str == null) {            return null;        }        return Double.valueOf(str);    }
public static Integer createInteger(final String str) {        if (str == null) {            return null;        }                return Integer.decode(str);    }
public static Long createLong(final String str) {        if (str == null) {            return null;        }        return Long.decode(str);    }
public static BigInteger createBigInteger(final String str) {        if (str == null) {            return null;        }        int pos = 0;         int radix = 10;        boolean negate = false;         if (str.startsWith("-")) {            negate = true;            pos = 1;        }        if (str.startsWith("0x", pos) || str.startsWith("0x", pos)) {             radix = 16;            pos += 2;        } else if (str.startsWith("#", pos)) {             radix = 16;            pos ++;        } else if (str.startsWith("0", pos) && str.length() > pos + 1) {             radix = 8;            pos ++;        }         final BigInteger value = new BigInteger(str.substring(pos), radix);        return negate ? value.negate() : value;    }
public static BigDecimal createBigDecimal(final String str) {        if (str == null) {            return null;        }                if (StringUtils.isBlank(str)) {            throw new NumberFormatException("A blank string is not a valid number");        }        if (str.trim().startsWith("--")) {                                                            throw new NumberFormatException(str + " is not a valid number.");        }        return new BigDecimal(str);    }
public static long min(final long[] array) {                validateArray(array);                    long min = array[0];        for (int i = 1; i < array.length; i++) {            if (array[i] < min) {                min = array[i];            }        }            return min;    }
public static int min(final int[] array) {                validateArray(array);                    int min = array[0];        for (int j = 1; j < array.length; j++) {            if (array[j] < min) {                min = array[j];            }        }            return min;    }
public static short min(final short[] array) {                validateArray(array);                    short min = array[0];        for (int i = 1; i < array.length; i++) {            if (array[i] < min) {                min = array[i];            }        }            return min;    }
public static byte min(final byte[] array) {                validateArray(array);                    byte min = array[0];        for (int i = 1; i < array.length; i++) {            if (array[i] < min) {                min = array[i];            }        }            return min;    }
public static double min(final double[] array) {                validateArray(array);                    double min = array[0];        for (int i = 1; i < array.length; i++) {            if (Double.isNaN(array[i])) {                return Double.NaN;            }            if (array[i] < min) {                min = array[i];            }        }            return min;    }
public static float min(final float[] array) {                validateArray(array);                    float min = array[0];        for (int i = 1; i < array.length; i++) {            if (Float.isNaN(array[i])) {                return Float.NaN;            }            if (array[i] < min) {                min = array[i];            }        }            return min;    }
public static long max(final long[] array) {                validateArray(array);                long max = array[0];        for (int j = 1; j < array.length; j++) {            if (array[j] > max) {                max = array[j];            }        }        return max;    }
public static int max(final int[] array) {                validateArray(array);                    int max = array[0];        for (int j = 1; j < array.length; j++) {            if (array[j] > max) {                max = array[j];            }        }            return max;    }
public static short max(final short[] array) {                validateArray(array);                    short max = array[0];        for (int i = 1; i < array.length; i++) {            if (array[i] > max) {                max = array[i];            }        }            return max;    }
public static byte max(final byte[] array) {                validateArray(array);                    byte max = array[0];        for (int i = 1; i < array.length; i++) {            if (array[i] > max) {                max = array[i];            }        }            return max;    }
public static double max(final double[] array) {                validateArray(array);                double max = array[0];        for (int j = 1; j < array.length; j++) {            if (Double.isNaN(array[j])) {                return Double.NaN;            }            if (array[j] > max) {                max = array[j];            }        }            return max;    }
public static float max(final float[] array) {                validateArray(array);                float max = array[0];        for (int j = 1; j < array.length; j++) {            if (Float.isNaN(array[j])) {                return Float.NaN;            }            if (array[j] > max) {                max = array[j];            }        }        return max;    }
public static long min(long a, final long b, final long c) {        if (b < a) {            a = b;        }        if (c < a) {            a = c;        }        return a;    }
public static int min(int a, final int b, final int c) {        if (b < a) {            a = b;        }        if (c < a) {            a = c;        }        return a;    }
public static short min(short a, final short b, final short c) {        if (b < a) {            a = b;        }        if (c < a) {            a = c;        }        return a;    }
public static byte min(byte a, final byte b, final byte c) {        if (b < a) {            a = b;        }        if (c < a) {            a = c;        }        return a;    }
public static double min(final double a, final double b, final double c) {        return Math.min(Math.min(a, b), c);    }
public static float min(final float a, final float b, final float c) {        return Math.min(Math.min(a, b), c);    }
public static long max(long a, final long b, final long c) {        if (b > a) {            a = b;        }        if (c > a) {            a = c;        }        return a;    }
public static int max(int a, final int b, final int c) {        if (b > a) {            a = b;        }        if (c > a) {            a = c;        }        return a;    }
public static short max(short a, final short b, final short c) {        if (b > a) {            a = b;        }        if (c > a) {            a = c;        }        return a;    }
public static byte max(byte a, final byte b, final byte c) {        if (b > a) {            a = b;        }        if (c > a) {            a = c;        }        return a;    }
public static double max(final double a, final double b, final double c) {        return Math.max(Math.max(a, b), c);    }
public static float max(final float a, final float b, final float c) {        return Math.max(Math.max(a, b), c);    }
public static boolean isDigits(final String str) {        if (StringUtils.isEmpty(str)) {            return false;        }        for (int i = 0; i < str.length(); i++) {            if (!Character.isDigit(str.charAt(i))) {                return false;            }        }        return true;    }
public static boolean isNumber(final String str) {        if (StringUtils.isEmpty(str)) {            return false;        }        final char[] chars = str.toCharArray();        int sz = chars.length;        boolean hasExp = false;        boolean hasDecPoint = false;        boolean allowSigns = false;        boolean foundDigit = false;                final int start = (chars[0] == '-') ? 1 : 0;        if (sz > start + 1 && chars[start] == '0' && chars[start + 1] == 'x') {            int i = start + 2;            if (i == sz) {                return false;             }                        for (; i < chars.length; i++) {                if ((chars[i] < '0' || chars[i] > '9')                    && (chars[i] < 'a' || chars[i] > 'f')                    && (chars[i] < 'A' || chars[i] > 'F')) {                    return false;                }            }            return true;        }        sz--;                       int i = start;                        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {            if (chars[i] >= '0' && chars[i] <= '9') {                foundDigit = true;                allowSigns = false;            } else if (chars[i] == '.') {                if (hasDecPoint || hasExp) {                                        return false;                }                hasDecPoint = true;            } else if (chars[i] == 'e' || chars[i] == 'E') {                                if (hasExp) {                                        return false;                }                if (!foundDigit) {                    return false;                }                hasExp = true;                allowSigns = true;            } else if (chars[i] == '+' || chars[i] == '-') {                if (!allowSigns) {                    return false;                }                allowSigns = false;                foundDigit = false;             } else {                return false;            }            i++;        }        if (i < chars.length) {            if (chars[i] >= '0' && chars[i] <= '9') {                                return true;            }            if (chars[i] == 'e' || chars[i] == 'E') {                                return false;            }            if (chars[i] == '.') {                if (hasDecPoint || hasExp) {                                        return false;                }                                return foundDigit;            }            if (!allowSigns                && (chars[i] == 'd'                    || chars[i] == 'D'                    || chars[i] == 'f'                    || chars[i] == 'F')) {                return foundDigit;            }            if (chars[i] == 'l'                || chars[i] == 'L') {                                return foundDigit && !hasExp && !hasDecPoint;            }                        return false;        }                        return !allowSigns && foundDigit;    }
----------------------------------------------------------------------------------------------------
public static String random(final int count) {        return random(count, false, false);    }
public static String randomAscii(final int count) {        return random(count, 32, 127, false, false);    }
public static String randomAlphabetic(final int count) {        return random(count, true, false);    }
public static String randomAlphanumeric(final int count) {        return random(count, true, true);    }
public static String randomNumeric(final int count) {        return random(count, false, true);    }
public static String random(final int count, final boolean letters, final boolean numbers) {        return random(count, 0, 0, letters, numbers);    }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers) {        return random(count, start, end, letters, numbers, null, RANDOM);    }
public static String random(final int count, final int start, final int end, final boolean letters, final boolean numbers, final char... chars) {        return random(count, start, end, letters, numbers, chars, RANDOM);    }
public static String random(int count, int start, int end, final boolean letters, final boolean numbers, final char[] chars, final Random random) {        if (count == 0) {            return "";        } else if (count < 0) {            throw new IllegalArgumentException("Requested random string length " + count + " is less than 0.");        }        if (chars != null && chars.length == 0) {            throw new IllegalArgumentException("The chars array must not be empty");        }        if (start == 0 && end == 0) {            if (chars != null) {                end = chars.length;            } else {                if (!letters && !numbers) {                    end = Integer.MAX_VALUE;                } else {                    end = 'z' + 1;                    start = ' ';                                }            }        } else {            if (end <= start) {                throw new IllegalArgumentException("Parameter end (" + end + ") must be greater than start (" + start + ")");            }        }        final char[] buffer = new char[count];        final int gap = end - start;        while (count-- != 0) {            char ch;            if (chars == null) {                ch = (char) (random.nextInt(gap) + start);            } else {                ch = chars[random.nextInt(gap) + start];            }            if (letters && Character.isLetter(ch)                    || numbers && Character.isDigit(ch)                    || !letters && !numbers) {                if(ch >= 56320 && ch <= 57343) {                    if(count == 0) {                        count++;                    } else {                        buffer[count] = ch;                        count--;                        buffer[count] = (char) (55296 + random.nextInt(128));                    }                } else if(ch >= 55296 && ch <= 56191) {                    if(count == 0) {                        count++;                    } else {                        buffer[count] = (char) (56320 + random.nextInt(128));                        count--;                        buffer[count] = ch;                    }                } else if(ch >= 56192 && ch <= 56319) {                    count++;                } else {                    buffer[count] = ch;                }            } else {                count++;            }        }        return new String(buffer);    }
public static String random(final int count, final String chars) {        if (chars == null) {            return random(count, 0, 0, false, false, null, RANDOM);        }        return random(count, chars.toCharArray());    }
public static String random(final int count, final char... chars) {        if (chars == null) {            return random(count, 0, 0, false, false, null, RANDOM);        }        return random(count, 0, chars.length, false, false, chars, RANDOM);    }
----------------------------------------------------------------------------------------------------
public void start() {        if (this.runningState == STATE_STOPPED) {            throw new IllegalStateException("Stopwatch must be reset before being restarted. ");        }        if (this.runningState != STATE_UNSTARTED) {            throw new IllegalStateException("Stopwatch already started. ");        }        this.startTime = System.nanoTime();        this.startTimeMillis = System.currentTimeMillis();        this.runningState = STATE_RUNNING;    }
public void stop() {        if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {            throw new IllegalStateException("Stopwatch is not running. ");        }        if (this.runningState == STATE_RUNNING) {            this.stopTime = System.nanoTime();        }        this.runningState = STATE_STOPPED;    }
public void reset() {        this.runningState = STATE_UNSTARTED;        this.splitState = STATE_UNSPLIT;    }
public void split() {        if (this.runningState != STATE_RUNNING) {            throw new IllegalStateException("Stopwatch is not running. ");        }        this.stopTime = System.nanoTime();        this.splitState = STATE_SPLIT;    }
public void unsplit() {        if (this.splitState != STATE_SPLIT) {            throw new IllegalStateException("Stopwatch has not been split. ");        }        this.splitState = STATE_UNSPLIT;    }
public void suspend() {        if (this.runningState != STATE_RUNNING) {            throw new IllegalStateException("Stopwatch must be running to suspend. ");        }        this.stopTime = System.nanoTime();        this.runningState = STATE_SUSPENDED;    }
public void resume() {        if (this.runningState != STATE_SUSPENDED) {            throw new IllegalStateException("Stopwatch must be suspended to resume. ");        }        this.startTime += System.nanoTime() - this.stopTime;        this.runningState = STATE_RUNNING;    }
public long getTime() {        return getNanoTime() / NANO_2_MILLIS;    }
public long getNanoTime() {        if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {            return this.stopTime - this.startTime;        } else if (this.runningState == STATE_UNSTARTED) {            return 0;        } else if (this.runningState == STATE_RUNNING) {            return System.nanoTime() - this.startTime;        }        throw new RuntimeException("Illegal running state has occurred.");    }
public long getSplitTime() {        return getSplitNanoTime() / NANO_2_MILLIS;    }
public long getSplitNanoTime() {        if (this.splitState != STATE_SPLIT) {            throw new IllegalStateException("Stopwatch must be split to get the split time. ");        }        return this.stopTime - this.startTime;    }
public long getStartTime() {        if (this.runningState == STATE_UNSTARTED) {            throw new IllegalStateException("Stopwatch has not been started");        }                return this.startTimeMillis;    }
public String toString() {        return DurationFormatUtils.formatDurationHMS(getTime());    }
public String toSplitString() {        return DurationFormatUtils.formatDurationHMS(getSplitTime());    }
----------------------------------------------------------------------------------------------------
public static File getJavaHome() {        return new File(System.getProperty(JAVA_HOME_KEY));    }
public static File getJavaIoTmpDir() {        return new File(System.getProperty(JAVA_IO_TMPDIR_KEY));    }
public static File getUserDir() {        return new File(System.getProperty(USER_DIR_KEY));    }
public static File getUserHome() {        return new File(System.getProperty(USER_HOME_KEY));    }
public static boolean isJavaAwtHeadless() {        return JAVA_AWT_HEADLESS != null ? JAVA_AWT_HEADLESS.equals(Boolean.TRUE.toString()) : false;    }
public static boolean isJavaVersionAtLeast(final JavaVersion requiredVersion) {        return JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);    }
----------------------------------------------------------------------------------------------------
public void appendSuper(final StringBuffer buffer, final String superToString) {        appendToString(buffer, superToString);    }
public void appendToString(final StringBuffer buffer, final String toString) {        if (toString != null) {            final int pos1 = toString.indexOf(contentStart) + contentStart.length();            final int pos2 = toString.lastIndexOf(contentEnd);            if (pos1 != pos2 && pos1 >= 0 && pos2 >= 0) {                final String data = toString.substring(pos1, pos2);                if (fieldSeparatorAtStart) {                    removeLastFieldSeparator(buffer);                }                buffer.append(data);                appendFieldSeparator(buffer);            }        }    }
public void appendStart(final StringBuffer buffer, final Object object) {        if (object != null) {            appendClassName(buffer, object);            appendIdentityHashCode(buffer, object);            appendContentStart(buffer);            if (fieldSeparatorAtStart) {                appendFieldSeparator(buffer);            }        }    }
public void appendEnd(final StringBuffer buffer, final Object object) {        if (this.fieldSeparatorAtEnd == false) {            removeLastFieldSeparator(buffer);        }        appendContentEnd(buffer);        unregister(object);    }
public void append(final StringBuffer buffer, final String fieldName, final Object value, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (value == null) {            appendNullText(buffer, fieldName);        } else {            appendInternal(buffer, fieldName, value, isFullDetail(fullDetail));        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final long value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final int value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final short value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final byte value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final char value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final double value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final float value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final boolean value) {        appendFieldStart(buffer, fieldName);        appendDetail(buffer, fieldName, value);        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final Object[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final long[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final int[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final short[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final byte[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final char[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final double[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final float[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public void append(final StringBuffer buffer, final String fieldName, final boolean[] array, final Boolean fullDetail) {        appendFieldStart(buffer, fieldName);        if (array == null) {            appendNullText(buffer, fieldName);        } else if (isFullDetail(fullDetail)) {            appendDetail(buffer, fieldName, array);        } else {            appendSummary(buffer, fieldName, array);        }        appendFieldEnd(buffer, fieldName);    }
public String getArrayStart() {        return arrayStart;    }
public void setArrayStart(String arrayStart) {        if (arrayStart == null) {            arrayStart = "";        }        this.arrayStart = arrayStart;    }
public String getArrayEnd() {        return arrayEnd;    }
public void setArrayEnd(String arrayEnd) {        if (arrayEnd == null) {            arrayEnd = "";        }        this.arrayEnd = arrayEnd;    }
public String getArraySeparator() {        return arraySeparator;    }
public void setArraySeparator(String arraySeparator) {        if (arraySeparator == null) {            arraySeparator = "";        }        this.arraySeparator = arraySeparator;    }
public String getContentStart() {        return contentStart;    }
public void setContentStart(String contentStart) {        if (contentStart == null) {            contentStart = "";        }        this.contentStart = contentStart;    }
public String getContentEnd() {        return contentEnd;    }
public void setContentEnd(String contentEnd) {        if (contentEnd == null) {            contentEnd = "";        }        this.contentEnd = contentEnd;    }
public String getFieldNameValueSeparator() {        return fieldNameValueSeparator;    }
public void setFieldNameValueSeparator(String fieldNameValueSeparator) {        if (fieldNameValueSeparator == null) {            fieldNameValueSeparator = "";        }        this.fieldNameValueSeparator = fieldNameValueSeparator;    }
public String getFieldSeparator() {        return fieldSeparator;    }
public void setFieldSeparator(String fieldSeparator) {        if (fieldSeparator == null) {            fieldSeparator = "";        }        this.fieldSeparator = fieldSeparator;    }
public String getNullText() {        return nullText;    }
public void setNullText(String nullText) {        if (nullText == null) {            nullText = "";        }        this.nullText = nullText;    }
public String getSizeStartText() {        return sizeStartText;    }
public void setSizeStartText(String sizeStartText) {        if (sizeStartText == null) {            sizeStartText = "";        }        this.sizeStartText = sizeStartText;    }
public String getSizeEndText() {        return sizeEndText;    }
public void setSizeEndText(String sizeEndText) {        if (sizeEndText == null) {            sizeEndText = "";        }        this.sizeEndText = sizeEndText;    }
public String getSummaryObjectStartText() {        return summaryObjectStartText;    }
public void setSummaryObjectStartText(String summaryObjectStartText) {        if (summaryObjectStartText == null) {            summaryObjectStartText = "";        }        this.summaryObjectStartText = summaryObjectStartText;    }
public String getSummaryObjectEndText() {        return summaryObjectEndText;    }
public void setSummaryObjectEndText(String summaryObjectEndText) {        if (summaryObjectEndText == null) {            summaryObjectEndText = "";        }        this.summaryObjectEndText = summaryObjectEndText;    }
----------------------------------------------------------------------------------------------------
public static boolean isAssignable(final Type type, final Type toType) {        return isAssignable(type, toType, null);    }
public static boolean isInstance(final Object value, final Type type) {        if (type == null) {            return false;        }        return value == null ? !(type instanceof Class<?>) || !((Class<?>) type).isPrimitive()                : isAssignable(value.getClass(), type, null);    }
public static Type[] normalizeUpperBounds(final Type[] bounds) {        if (bounds.length < 2) {            return bounds;        }        final Set<Type> types = new HashSet<Type>(bounds.length);        for (final Type type1 : bounds) {            boolean subtypeFound = false;            for (final Type type2 : bounds) {                if (type1 != type2 && isAssignable(type2, type1, null)) {                    subtypeFound = true;                    break;                }            }            if (!subtypeFound) {                types.add(type1);            }        }        return types.toArray(new Type[types.size()]);    }
public static Type[] getImplicitBounds(final TypeVariable<?> typeVariable) {        final Type[] bounds = typeVariable.getBounds();        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);    }
public static Type[] getImplicitUpperBounds(final WildcardType wildcardType) {        final Type[] bounds = wildcardType.getUpperBounds();        return bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);    }
public static Type[] getImplicitLowerBounds(final WildcardType wildcardType) {        final Type[] bounds = wildcardType.getLowerBounds();        return bounds.length == 0 ? new Type[] { null } : bounds;    }
public static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns) {        for (final Map.Entry<TypeVariable<?>, Type> entry : typeVarAssigns.entrySet()) {            final TypeVariable<?> typeVar = entry.getKey();            final Type type = entry.getValue();            for (final Type bound : getImplicitBounds(typeVar)) {                if (!isAssignable(type, substituteTypeVariables(bound, typeVarAssigns),                        typeVarAssigns)) {                    return false;                }            }        }        return true;    }
public static Class<?> getRawType(final Type type, final Type assigningType) {        if (type instanceof Class<?>) {            return (Class<?>) type;        }        if (type instanceof ParameterizedType) {            return getRawType((ParameterizedType) type);        }        if (type instanceof TypeVariable<?>) {            if (assigningType == null) {                return null;            }            final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();            if (!(genericDeclaration instanceof Class<?>)) {                return null;            }            final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType,                    (Class<?>) genericDeclaration);            if (typeVarAssigns == null) {                return null;            }            final Type typeArgument = typeVarAssigns.get(type);            if (typeArgument == null) {                return null;            }            return getRawType(typeArgument, assigningType);        }        if (type instanceof GenericArrayType) {            final Class<?> rawComponentType = getRawType(((GenericArrayType) type)                    .getGenericComponentType(), assigningType);            return Array.newInstance(rawComponentType, 0).getClass();        }        if (type instanceof WildcardType) {            return null;        }        throw new IllegalArgumentException("unknown type: " + type);    }
public static boolean isArrayType(final Type type) {        return type instanceof GenericArrayType || type instanceof Class<?> && ((Class<?>) type).isArray();    }
public static Type getArrayComponentType(final Type type) {        if (type instanceof Class<?>) {            final Class<?> clazz = (Class<?>) type;            return clazz.isArray() ? clazz.getComponentType() : null;        }        if (type instanceof GenericArrayType) {            return ((GenericArrayType) type).getGenericComponentType();        }        return null;    }
----------------------------------------------------------------------------------------------------
public static String wrap(final String str, final int wrapLength) {        return wrap(str, wrapLength, null, false);    }
public static String wrap(final String str, int wrapLength, String newLineStr, final boolean wrapLongWords) {        if (str == null) {            return null;        }        if (newLineStr == null) {            newLineStr = SystemUtils.LINE_SEPARATOR;        }        if (wrapLength < 1) {            wrapLength = 1;        }        final int inputLineLength = str.length();        int offset = 0;        final StringBuilder wrappedLine = new StringBuilder(inputLineLength + 32);                while (inputLineLength - offset > wrapLength) {            if (str.charAt(offset) == ' ') {                offset++;                continue;            }            int spaceToWrapAt = str.lastIndexOf(' ', wrapLength + offset);            if (spaceToWrapAt >= offset) {                                wrappedLine.append(str.substring(offset, spaceToWrapAt));                wrappedLine.append(newLineStr);                offset = spaceToWrapAt + 1;                            } else {                                if (wrapLongWords) {                                        wrappedLine.append(str.substring(offset, wrapLength + offset));                    wrappedLine.append(newLineStr);                    offset += wrapLength;                } else {                                        spaceToWrapAt = str.indexOf(' ', wrapLength + offset);                    if (spaceToWrapAt >= 0) {                        wrappedLine.append(str.substring(offset, spaceToWrapAt));                        wrappedLine.append(newLineStr);                        offset = spaceToWrapAt + 1;                    } else {                        wrappedLine.append(str.substring(offset));                        offset = inputLineLength;                    }                }            }        }                wrappedLine.append(str.substring(offset));        return wrappedLine.toString();    }
public static String capitalize(final String str) {        return capitalize(str, null);    }
public static String capitalize(final String str, final char... delimiters) {        final int delimLen = delimiters == null ? -1 : delimiters.length;        if (StringUtils.isEmpty(str) || delimLen == 0) {            return str;        }        final char[] buffer = str.toCharArray();        boolean capitalizeNext = true;        for (int i = 0; i < buffer.length; i++) {            final char ch = buffer[i];            if (isDelimiter(ch, delimiters)) {                capitalizeNext = true;            } else if (capitalizeNext) {                buffer[i] = Character.toTitleCase(ch);                capitalizeNext = false;            }        }        return new String(buffer);    }
public static String capitalizeFully(final String str) {        return capitalizeFully(str, null);    }
public static String capitalizeFully(String str, final char... delimiters) {        final int delimLen = delimiters == null ? -1 : delimiters.length;        if (StringUtils.isEmpty(str) || delimLen == 0) {            return str;        }        str = str.toLowerCase();        return capitalize(str, delimiters);    }
public static String uncapitalize(final String str) {        return uncapitalize(str, null);    }
public static String uncapitalize(final String str, final char... delimiters) {        final int delimLen = delimiters == null ? -1 : delimiters.length;        if (StringUtils.isEmpty(str) || delimLen == 0) {            return str;        }        final char[] buffer = str.toCharArray();        boolean uncapitalizeNext = true;        for (int i = 0; i < buffer.length; i++) {            final char ch = buffer[i];            if (isDelimiter(ch, delimiters)) {                uncapitalizeNext = true;            } else if (uncapitalizeNext) {                buffer[i] = Character.toLowerCase(ch);                uncapitalizeNext = false;            }        }        return new String(buffer);    }
public static String swapCase(final String str) {        if (StringUtils.isEmpty(str)) {            return str;        }        final char[] buffer = str.toCharArray();        boolean whitespace = true;        for (int i = 0; i < buffer.length; i++) {            final char ch = buffer[i];            if (Character.isUpperCase(ch)) {                buffer[i] = Character.toLowerCase(ch);                whitespace = false;            } else if (Character.isTitleCase(ch)) {                buffer[i] = Character.toLowerCase(ch);                whitespace = false;            } else if (Character.isLowerCase(ch)) {                if (whitespace) {                    buffer[i] = Character.toTitleCase(ch);                    whitespace = false;                } else {                    buffer[i] = Character.toUpperCase(ch);                }            } else {                whitespace = Character.isWhitespace(ch);            }        }        return new String(buffer);    }
public static String initials(final String str) {        return initials(str, null);    }
public static String initials(final String str, final char... delimiters) {        if (StringUtils.isEmpty(str)) {            return str;        }        if (delimiters != null && delimiters.length == 0) {            return "";        }        final int strLen = str.length();        final char[] buf = new char[strLen / 2 + 1];        int count = 0;        boolean lastWasGap = true;        for (int i = 0; i < strLen; i++) {            final char ch = str.charAt(i);            if (isDelimiter(ch, delimiters)) {                lastWasGap = true;            } else if (lastWasGap) {                buf[count++] = ch;                lastWasGap = false;            } else {                continue;             }        }        return new String(buf, 0, count);    }
----------------------------------------------------------------------------------------------------
