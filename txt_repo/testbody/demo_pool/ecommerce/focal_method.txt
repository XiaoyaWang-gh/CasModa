@GetMapping public ResponseEntity<DtoCollectionResponse<FavouriteDto>> findAll() {     log.info("*** FavouriteDto List, controller; fetch all favourites *");     return ResponseEntity.ok(new DtoCollectionResponse<>(this.favouriteService.findAll())); }
@GetMapping("/find") public ResponseEntity<FavouriteDto> findById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** FavouriteDto, resource; fetch favourite by id *");     return ResponseEntity.ok(this.favouriteService.findById(favouriteId)); }
@GetMapping("/find") public ResponseEntity<FavouriteDto> findById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** FavouriteDto, resource; fetch favourite by id *");     return ResponseEntity.ok(this.favouriteService.findById(favouriteId)); }
@PostMapping public ResponseEntity<FavouriteDto> save(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteDto favouriteDto) {     log.info("*** FavouriteDto, resource; save favourite *");     return ResponseEntity.ok(this.favouriteService.save(favouriteDto)); }
@PutMapping public ResponseEntity<FavouriteDto> update(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteDto favouriteDto) {     log.info("*** FavouriteDto, resource; update favourite *");     return ResponseEntity.ok(this.favouriteService.update(favouriteDto)); }
@DeleteMapping("/delete") public ResponseEntity<Boolean> deleteById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** Boolean, resource; delete favourite by id *");     this.favouriteService.deleteById(favouriteId);     return ResponseEntity.ok(true); }
@DeleteMapping("/delete") public ResponseEntity<Boolean> deleteById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** Boolean, resource; delete favourite by id *");     this.favouriteService.deleteById(favouriteId);     return ResponseEntity.ok(true); }
public static void main(String[] args) {     SpringApplication.run(FavouriteServiceApplication.class, args); }
@GetMapping public ResponseEntity<DtoCollectionResponse<FavouriteDto>> findAll() {     log.info("*** FavouriteDto List, controller; fetch all favourites *");     return ResponseEntity.ok(new DtoCollectionResponse<>(this.favouriteService.findAll())); }
@GetMapping("/find") public ResponseEntity<FavouriteDto> findById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** FavouriteDto, resource; fetch favourite by id *");     return ResponseEntity.ok(this.favouriteService.findById(favouriteId)); }
@GetMapping("/find") public ResponseEntity<FavouriteDto> findById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** FavouriteDto, resource; fetch favourite by id *");     return ResponseEntity.ok(this.favouriteService.findById(favouriteId)); }
@PostMapping public ResponseEntity<FavouriteDto> save(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteDto favouriteDto) {     log.info("*** FavouriteDto, resource; save favourite *");     return ResponseEntity.ok(this.favouriteService.save(favouriteDto)); }
@PostMapping public ResponseEntity<FavouriteDto> save(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteDto favouriteDto) {     log.info("*** FavouriteDto, resource; save favourite *");     return ResponseEntity.ok(this.favouriteService.save(favouriteDto)); }
@PutMapping public ResponseEntity<FavouriteDto> update(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteDto favouriteDto) {     log.info("*** FavouriteDto, resource; update favourite *");     return ResponseEntity.ok(this.favouriteService.update(favouriteDto)); }
@DeleteMapping("/delete") public ResponseEntity<Boolean> deleteById(@RequestBody @NotNull(message = "Input must not be NULL") @Valid final FavouriteId favouriteId) {     log.info("*** Boolean, resource; delete favourite by id *");     this.favouriteService.deleteById(favouriteId);     return ResponseEntity.ok(true); }
@Override public List<CartDto> findAll() {     log.info("*** CartDto List, service; fetch all carts *");     return this.cartRepository.findAll().stream().map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).distinct().collect(Collectors.toUnmodifiableList()); }
public static Order map(final OrderDto orderDto) {     return Order.builder().orderId(orderDto.getOrderId()).orderDate(orderDto.getOrderDate()).orderDesc(orderDto.getOrderDesc()).orderFee(orderDto.getOrderFee()).cart(Cart.builder().cartId(orderDto.getCartDto().getCartId()).build()).build(); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public void deleteById(final Integer cartId) {     log.info("*** Void, service; delete cart by id *");     this.cartRepository.deleteById(cartId); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public List<CartDto> findAll() {     log.info("*** CartDto List, service; fetch all carts *");     return this.cartRepository.findAll().stream().map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).distinct().collect(Collectors.toUnmodifiableList()); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public void deleteById(final Integer cartId) {     log.info("*** Void, service; delete cart by id *");     this.cartRepository.deleteById(cartId); }
@Override public List<CartDto> findAll() {     log.info("*** CartDto List, service; fetch all carts *");     return this.cartRepository.findAll().stream().map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).distinct().collect(Collectors.toUnmodifiableList()); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public void deleteById(final Integer cartId) {     log.info("*** Void, service; delete cart by id *");     this.cartRepository.deleteById(cartId); }
@GetMapping public String msg() {     return "Order controller responding!!"; }
@GetMapping public String msg() {     return "Order controller responding!!"; }
@Override public List<CartDto> findAll() {     log.info("*** CartDto List, service; fetch all carts *");     return this.cartRepository.findAll().stream().map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).distinct().collect(Collectors.toUnmodifiableList()); }
@Override public CartDto findById(final Integer cartId) {     log.info("*** CartDto, service; fetch cart by id *");     return this.cartRepository.findById(cartId).map(CartMappingHelper::map).map(c -> {         c.setUserDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.USER_SERVICE_API_URL + "/" + c.getUserDto().getUserId(), UserDto.class));         return c;     }).orElseThrow(() -> new CartNotFoundException(String.format("Cart with id: %d not found", cartId))); }
@Override public CartDto save(final CartDto cartDto) {     log.info("*** CartDto, service; save cart *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(cartDto))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public CartDto update(final Integer cartId, final CartDto cartDto) {     log.info("*** CartDto, service; update cart with cartId *");     return CartMappingHelper.map(this.cartRepository.save(CartMappingHelper.map(this.findById(cartId)))); }
@Override public void deleteById(final Integer cartId) {     log.info("*** Void, service; delete cart by id *");     this.cartRepository.deleteById(cartId); }
@Override 	public List<PaymentDto> findAll() { 		log.info("*** PaymentDto List, service; fetch all payments *"); 		return this.paymentRepository.findAll() 				.stream() 					.map(PaymentMappingHelper::map) 					.map(p -> { 						p.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi 								.ORDER_SERVICE_API_URL + "/" + p.getOrderDto().getOrderId(), OrderDto.class)); 						return p; 					}) 					.distinct() 					.collect(Collectors.toUnmodifiableList()); 	}
@Override 	public PaymentDto findById(final Integer paymentId) { 		log.info("*** PaymentDto, service; fetch payment by id *"); 		return this.paymentRepository.findById(paymentId) 				.map(PaymentMappingHelper::map) 				.map(p -> { 					p.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi 							.ORDER_SERVICE_API_URL + "/" + p.getOrderDto().getOrderId(), OrderDto.class)); 					return p; 				}) 				.orElseThrow(() -> new PaymentNotFoundException(String.format("Payment with id: %d not found", paymentId))); 	}
@Override 	public PaymentDto findById(final Integer paymentId) { 		log.info("*** PaymentDto, service; fetch payment by id *"); 		return this.paymentRepository.findById(paymentId) 				.map(PaymentMappingHelper::map) 				.map(p -> { 					p.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi 							.ORDER_SERVICE_API_URL + "/" + p.getOrderDto().getOrderId(), OrderDto.class)); 					return p; 				}) 				.orElseThrow(() -> new PaymentNotFoundException(String.format("Payment with id: %d not found", paymentId))); 	}
@Override 	public PaymentDto save(final PaymentDto paymentDto) { 		log.info("*** PaymentDto, service; save payment *"); 		return PaymentMappingHelper.map(this.paymentRepository 				.save(PaymentMappingHelper.map(paymentDto))); 	}
@Override 	public PaymentDto save(final PaymentDto paymentDto) { 		log.info("*** PaymentDto, service; save payment *"); 		return PaymentMappingHelper.map(this.paymentRepository 				.save(PaymentMappingHelper.map(paymentDto))); 	}
@Override 	public PaymentDto update(final PaymentDto paymentDto) { 		log.info("*** PaymentDto, service; update payment *"); 		return PaymentMappingHelper.map(this.paymentRepository 				.save(PaymentMappingHelper.map(paymentDto))); 	}
@Override	public void deleteById(final Integer paymentId) {		log.info("*** Void, service; delete payment by id *");		this.paymentRepository.deleteById(paymentId);	}
@Override public List<ProductDto> findAll() {     log.info("*** ProductDto List, service; fetch all products *");     return this.productRepository.findAll().stream().map(ProductMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto update(final Integer productId, final ProductDto productDto) {     log.info("*** ProductDto, service; update product with productId *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(this.findById(productId)))); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
@Override public ProductDto update(final Integer productId, final ProductDto productDto) {     log.info("*** ProductDto, service; update product with productId *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(this.findById(productId)))); }
@Override public void deleteById(final Integer productId) {     log.info("*** Void, service; delete product by id *");     this.productRepository.delete(ProductMappingHelper.map(this.findById(productId))); }
@Override public List<ProductDto> findAll() {     log.info("*** ProductDto List, service; fetch all products *");     return this.productRepository.findAll().stream().map(ProductMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto update(final Integer productId, final ProductDto productDto) {     log.info("*** ProductDto, service; update product with productId *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(this.findById(productId)))); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public ProductDto save(final ProductDto productDto) {     log.info("*** ProductDto, service; save product *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(productDto))); }
@Override public ProductDto update(final Integer productId, final ProductDto productDto) {     log.info("*** ProductDto, service; update product with productId *");     return ProductMappingHelper.map(this.productRepository.save(ProductMappingHelper.map(this.findById(productId)))); }
@Override public ProductDto findById(final Integer productId) {     log.info("*** ProductDto, service; fetch product by id *");     return this.productRepository.findById(productId).map(ProductMappingHelper::map).orElseThrow(() -> new ProductNotFoundException(String.format("Product with id: %d not found", productId))); }
public static Category map(final CategoryDto categoryDto) {     final var parentCategoryDto = Optional.ofNullable(categoryDto.getParentCategoryDto()).orElseGet(() -> new CategoryDto());     return Category.builder().categoryId(categoryDto.getCategoryId()).categoryTitle(categoryDto.getCategoryTitle()).imageUrl(categoryDto.getImageUrl()).parentCategory(Category.builder().categoryId(parentCategoryDto.getCategoryId()).categoryTitle(parentCategoryDto.getCategoryTitle()).imageUrl(parentCategoryDto.getImageUrl()).build()).build(); }
@Override public void deleteById(final Integer productId) {     log.info("*** Void, service; delete product by id *");     this.productRepository.delete(ProductMappingHelper.map(this.findById(productId))); }
@ExceptionHandler(value = { MethodArgumentNotValidException.class, HttpMessageNotReadableException.class }) public <T extends BindException> ResponseEntity<ExceptionMsg> handleValidationException(final T e) {     log.info("**ApiExceptionHandler controller, handle validation exception*\n");     final var badRequest = HttpStatus.BAD_REQUEST;     return new ResponseEntity<>(ExceptionMsg.builder().msg("*" + e.getBindingResult().getFieldError().getDefaultMessage() + "!**").httpStatus(badRequest).timestamp(ZonedDateTime.now(ZoneId.systemDefault())).build(), badRequest); }
@ExceptionHandler(value = { MethodArgumentNotValidException.class, HttpMessageNotReadableException.class }) public <T extends BindException> ResponseEntity<ExceptionMsg> handleValidationException(final T e) {     log.info("**ApiExceptionHandler controller, handle validation exception*\n");     final var badRequest = HttpStatus.BAD_REQUEST;     return new ResponseEntity<>(ExceptionMsg.builder().msg("*" + e.getBindingResult().getFieldError().getDefaultMessage() + "!**").httpStatus(badRequest).timestamp(ZonedDateTime.now(ZoneId.systemDefault())).build(), badRequest); }
@ExceptionHandler(value = { CategoryNotFoundException.class, ProductNotFoundException.class }) public <T extends RuntimeException> ResponseEntity<ExceptionMsg> handleApiRequestException(final T e) {     log.info("**ApiExceptionHandler controller, handle API request*\n");     final var badRequest = HttpStatus.BAD_REQUEST;     return new ResponseEntity<>(ExceptionMsg.builder().msg("#### " + e.getMessage() + "! ####").httpStatus(badRequest).timestamp(ZonedDateTime.now(ZoneId.systemDefault())).build(), badRequest); }
@ExceptionHandler(value = { CategoryNotFoundException.class, ProductNotFoundException.class }) public <T extends RuntimeException> ResponseEntity<ExceptionMsg> handleApiRequestException(final T e) {     log.info("**ApiExceptionHandler controller, handle API request*\n");     final var badRequest = HttpStatus.BAD_REQUEST;     return new ResponseEntity<>(ExceptionMsg.builder().msg("#### " + e.getMessage() + "! ####").httpStatus(badRequest).timestamp(ZonedDateTime.now(ZoneId.systemDefault())).build(), badRequest); }
@Override public List<OrderItemDto> findAll() {     log.info("*** OrderItemDto List, service; fetch all orderItems *");     return this.orderItemRepository.findAll().stream().map(OrderItemMappingHelper::map).map(o -> {         o.setProductDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.PRODUCT_SERVICE_API_URL + "/" + o.getProductDto().getProductId(), ProductDto.class));         o.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.ORDER_SERVICE_API_URL + "/" + o.getOrderDto().getOrderId(), OrderDto.class));         return o;     }).distinct().collect(Collectors.toUnmodifiableList()); }
public static OrderItem map(final OrderItemDto orderItemDto) {     return OrderItem.builder().productId(orderItemDto.getProductId()).orderId(orderItemDto.getOrderId()).orderedQuantity(orderItemDto.getOrderedQuantity()).build(); }
@Override public OrderItemDto findById(final OrderItemId orderItemId) {     log.info("*** OrderItemDto, service; fetch orderItem by id *");     return this.orderItemRepository.findById(null).map(OrderItemMappingHelper::map).map(o -> {         o.setProductDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.PRODUCT_SERVICE_API_URL + "/" + o.getProductDto().getProductId(), ProductDto.class));         o.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.ORDER_SERVICE_API_URL + "/" + o.getOrderDto().getOrderId(), OrderDto.class));         return o;     }).orElseThrow(() -> new OrderItemNotFoundException(String.format("OrderItem with id: %s not found", orderItemId))); }
public static OrderItem map(final OrderItemDto orderItemDto) {     return OrderItem.builder().productId(orderItemDto.getProductId()).orderId(orderItemDto.getOrderId()).orderedQuantity(orderItemDto.getOrderedQuantity()).build(); }
@Override public OrderItemDto findById(final OrderItemId orderItemId) {     log.info("*** OrderItemDto, service; fetch orderItem by id *");     return this.orderItemRepository.findById(null).map(OrderItemMappingHelper::map).map(o -> {         o.setProductDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.PRODUCT_SERVICE_API_URL + "/" + o.getProductDto().getProductId(), ProductDto.class));         o.setOrderDto(this.restTemplate.getForObject(AppConstant.DiscoveredDomainsApi.ORDER_SERVICE_API_URL + "/" + o.getOrderDto().getOrderId(), OrderDto.class));         return o;     }).orElseThrow(() -> new OrderItemNotFoundException(String.format("OrderItem with id: %s not found", orderItemId))); }
@Override public OrderItemDto save(final OrderItemDto orderItemDto) {     log.info("*** OrderItemDto, service; save orderItem *");     return OrderItemMappingHelper.map(this.orderItemRepository.save(OrderItemMappingHelper.map(orderItemDto))); }
public static OrderItem map(final OrderItemDto orderItemDto) {     return OrderItem.builder().productId(orderItemDto.getProductId()).orderId(orderItemDto.getOrderId()).orderedQuantity(orderItemDto.getOrderedQuantity()).build(); }
@Override public OrderItemDto save(final OrderItemDto orderItemDto) {     log.info("*** OrderItemDto, service; save orderItem *");     return OrderItemMappingHelper.map(this.orderItemRepository.save(OrderItemMappingHelper.map(orderItemDto))); }
public static OrderItem map(final OrderItemDto orderItemDto) {     return OrderItem.builder().productId(orderItemDto.getProductId()).orderId(orderItemDto.getOrderId()).orderedQuantity(orderItemDto.getOrderedQuantity()).build(); }
@Override public OrderItemDto update(final OrderItemDto orderItemDto) {     log.info("*** OrderItemDto, service; update orderItem *");     return OrderItemMappingHelper.map(this.orderItemRepository.save(OrderItemMappingHelper.map(orderItemDto))); }
@Override public void deleteById(final OrderItemId orderItemId) {     log.info("*** Void, service; delete orderItem by id *");     this.orderItemRepository.deleteById(orderItemId); }
@Override public List<UserDto> findAll() {     log.info("*** UserDto List, service; fetch all users *");     return this.userRepository.findAll().stream().map(UserMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto update(final Integer userId, final UserDto userDto) {     log.info("*** UserDto, service; update user with userId *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(this.findById(userId)))); }
@Override public void deleteById(final Integer userId) {     log.info("*** Void, service; delete user by id *");     this.userRepository.deleteById(userId); }
Optional<User> findByCredentialUsername(final String username);
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findByUsername(final String username) {     log.info("*** UserDto, service; fetch user with username *");     return UserMappingHelper.map(this.userRepository.findByCredentialUsername(username).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with username: %s not found", username)))); }
Optional<User> findByCredentialUsername(final String username);
@Override public UserDto findByUsername(final String username) {     log.info("*** UserDto, service; fetch user with username *");     return UserMappingHelper.map(this.userRepository.findByCredentialUsername(username).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with username: %s not found", username)))); }
@Override public List<UserDto> findAll() {     log.info("*** UserDto List, service; fetch all users *");     return this.userRepository.findAll().stream().map(UserMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto update(final Integer userId, final UserDto userDto) {     log.info("*** UserDto, service; update user with userId *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(this.findById(userId)))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto update(final Integer userId, final UserDto userDto) {     log.info("*** UserDto, service; update user with userId *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(this.findById(userId)))); }
@Override public void deleteById(final Integer userId) {     log.info("*** Void, service; delete user by id *");     this.userRepository.deleteById(userId); }
@Override public List<UserDto> findAll() {     log.info("*** UserDto List, service; fetch all users *");     return this.userRepository.findAll().stream().map(UserMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto update(final Integer userId, final UserDto userDto) {     log.info("*** UserDto, service; update user with userId *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(this.findById(userId)))); }
@Override public void deleteById(final Integer userId) {     log.info("*** Void, service; delete user by id *");     this.userRepository.deleteById(userId); }
@Override public UserDto findByUsername(final String username) {     log.info("*** UserDto, service; fetch user with username *");     return UserMappingHelper.map(this.userRepository.findByCredentialUsername(username).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with username: %s not found", username)))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findByUsername(final String username) {     log.info("*** UserDto, service; fetch user with username *");     return UserMappingHelper.map(this.userRepository.findByCredentialUsername(username).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with username: %s not found", username)))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
@Override public List<UserDto> findAll() {     log.info("*** UserDto List, service; fetch all users *");     return this.userRepository.findAll().stream().map(UserMappingHelper::map).distinct().collect(Collectors.toUnmodifiableList()); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto findById(final Integer userId) {     log.info("*** UserDto, service; fetch user by id *");     return this.userRepository.findById(userId).map(UserMappingHelper::map).orElseThrow(() -> new UserObjectNotFoundException(String.format("User with id: %d not found", userId))); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto save(final UserDto userDto) {     log.info("*** UserDto, service; save user *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(userDto))); }
public static Credential map(final CredentialDto credentialDto) {     return Credential.builder().credentialId(credentialDto.getCredentialId()).username(credentialDto.getUsername()).password(credentialDto.getPassword()).roleBasedAuthority(credentialDto.getRoleBasedAuthority()).isEnabled(credentialDto.getIsEnabled()).isAccountNonExpired(credentialDto.getIsAccountNonExpired()).isAccountNonLocked(credentialDto.getIsAccountNonLocked()).isCredentialsNonExpired(credentialDto.getIsCredentialsNonExpired()).user(User.builder().userId(credentialDto.getUserDto().getUserId()).firstName(credentialDto.getUserDto().getFirstName()).lastName(credentialDto.getUserDto().getLastName()).imageUrl(credentialDto.getUserDto().getImageUrl()).email(credentialDto.getUserDto().getEmail()).phone(credentialDto.getUserDto().getPhone()).build()).build(); }
@Override public UserDto update(final Integer userId, final UserDto userDto) {     log.info("*** UserDto, service; update user with userId *");     return UserMappingHelper.map(this.userRepository.save(UserMappingHelper.map(this.findById(userId)))); }
@Override public void deleteById(final Integer userId) {     log.info("*** Void, service; delete user by id *");     this.userRepository.deleteById(userId); }
